/*
Copyright 2022 Zhaofeng Li and the Attic contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

//! `libnixstore` Bindings
#![allow(dead_code)]

use std::cell::UnsafeCell;
use std::io;
use std::pin::Pin;
use std::task::{Context, Poll};

use anyhow::Result;
use bytes::Bytes;
use futures::stream::{Stream, StreamExt};
use tokio::io::{AsyncWrite, AsyncWriteExt};

// The C++ implementation takes care of concurrency
#[repr(transparent)]
pub struct FfiNixStore(UnsafeCell<cxx::UniquePtr<ffi::CNixStore>>);

unsafe impl Send for FfiNixStore {}
unsafe impl Sync for FfiNixStore {}

impl FfiNixStore {
    pub fn store(&self) -> Pin<&mut ffi::CNixStore> {
        unsafe {
            let ptr = self.0.get().as_mut().unwrap();
            ptr.pin_mut()
        }
    }
}

/// Obtain a handle to the Nix store.
pub unsafe fn open_nix_store() -> Result<FfiNixStore> {
    match ffi::open_nix_store() {
        Ok(ptr) => {
            let cell = UnsafeCell::new(ptr);
            Ok(FfiNixStore(cell))
        }
        Err(e) => Err(e.into()),
    }
}

// TODO: Benchmark different implementations
// (tokio, crossbeam, flume)
mod mpsc {
    // Tokio
    pub use tokio::sync::mpsc::{
        UnboundedReceiver, UnboundedSender, error::SendError, unbounded_channel,
    };
}

/// Async write request.
#[derive(Debug)]
enum AsyncWriteMessage {
    Data(Vec<u8>),
    Error(String),
    Eof,
}

/// Async write request sender.
#[derive(Clone)]
pub struct AsyncWriteSender {
    sender: mpsc::UnboundedSender<AsyncWriteMessage>,
}

impl AsyncWriteSender {
    fn send(&mut self, data: &[u8]) -> Result<(), mpsc::SendError<AsyncWriteMessage>> {
        let message = AsyncWriteMessage::Data(Vec::from(data));
        self.sender.send(message)
    }

    fn eof(&mut self) -> Result<(), mpsc::SendError<AsyncWriteMessage>> {
        let message = AsyncWriteMessage::Eof;
        self.sender.send(message)
    }

    pub(crate) fn rust_error(
        &mut self,
        error: impl std::error::Error,
    ) -> Result<(), impl std::error::Error> {
        let message = AsyncWriteMessage::Error(error.to_string());
        self.sender.send(message)
    }
}

/// A wrapper of the `AsyncWrite` trait for the synchronous Nix C++ land.
pub struct AsyncWriteAdapter {
    receiver: mpsc::UnboundedReceiver<AsyncWriteMessage>,
    eof: bool,
}

impl AsyncWriteAdapter {
    pub fn new() -> (Self, Box<AsyncWriteSender>) {
        let (sender, receiver) = mpsc::unbounded_channel();

        let r = Self {
            receiver,
            eof: false,
        };
        let sender = Box::new(AsyncWriteSender { sender });

        (r, sender)
    }

    /// Write everything the sender sends to us.
    pub async fn write_all(mut self, mut writer: Box<dyn AsyncWrite + Unpin>) -> Result<()> {
        let writer = writer.as_mut();

        while let Some(data) = self.next().await {
            match data {
                Ok(v) => {
                    writer.write_all(&v).await?;
                }
                Err(e) => {
                    return Err(e.into());
                }
            }
        }

        if !self.eof {
            Err(io::Error::from(io::ErrorKind::BrokenPipe).into())
        } else {
            Ok(())
        }
    }
}

impl Stream for AsyncWriteAdapter {
    type Item = std::io::Result<Bytes>;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        match self.receiver.poll_recv(cx) {
            Poll::Pending => Poll::Pending,
            Poll::Ready(Some(message)) => {
                use AsyncWriteMessage::*;
                match message {
                    Data(v) => Poll::Ready(Some(Ok(v.into()))),
                    Error(exception) => {
                        let error = std::io::Error::new(
                            io::ErrorKind::Other,
                            format!("cxx error: {exception}"),
                        );
                        Poll::Ready(Some(Err(error)))
                    }
                    Eof => {
                        self.eof = true;
                        Poll::Ready(None)
                    }
                }
            }
            Poll::Ready(None) => {
                if !self.eof {
                    Poll::Ready(Some(Err(io::Error::from(io::ErrorKind::BrokenPipe))))
                } else {
                    Poll::Ready(None)
                }
            }
        }
    }
}

#[cxx::bridge]
/// Generated by `cxx.rs`.
///
/// Mid-level wrapper of `libnixstore` implemented in C++.
mod ffi {
    extern "Rust" {
        type AsyncWriteSender;
        fn send(self: &mut AsyncWriteSender, data: &[u8]) -> Result<()>;
        fn eof(self: &mut AsyncWriteSender) -> Result<()>;
    }

    unsafe extern "C++" {
        include!("nixcp/src/bindings/nix.hpp");

        // =========
        // CNixStore
        // =========

        /// Mid-level wrapper for the Unix Domain Socket Nix Store.
        type CNixStore;

        /// Queries information about a valid path.
        fn query_path_info(
            self: Pin<&mut CNixStore>,
            store_path: &[u8],
        ) -> Result<UniquePtr<CPathInfo>>;

        /// Computes the closure of a valid path.
        ///
        /// If `flip_directions` is true, the set of paths that can reach `store_path` is
        /// returned.
        fn compute_fs_closure(
            self: Pin<&mut CNixStore>,
            store_path: &[u8],
            flip_direction: bool,
            include_outputs: bool,
            include_derivers: bool,
        ) -> Result<UniquePtr<CxxVector<CxxString>>>;

        /// Creates a NAR dump from a path.
        fn nar_from_path(
            self: Pin<&mut CNixStore>,
            base_name: Vec<u8>,
            sender: Box<AsyncWriteSender>,
        ) -> Result<()>;

        /// Obtains a handle to the Nix store.
        fn open_nix_store() -> Result<UniquePtr<CNixStore>>;

        // =========
        // CPathInfo
        // =========

        /// Mid-level wrapper for the `nix::ValidPathInfo` struct.
        type CPathInfo;

        /// Returns the references of the store path.
        fn references(self: Pin<&mut CPathInfo>) -> UniquePtr<CxxVector<CxxString>>;

        /// Returns the possibly invalid signatures attached to the store path.
        fn sigs(self: Pin<&mut CPathInfo>) -> UniquePtr<CxxVector<CxxString>>;
    }
}
